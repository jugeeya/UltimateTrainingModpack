// TODO!(Do all these need to be referenced by offset? Or do some of them have symbols?)
#![cfg_attr(rustfmt, rustfmt_skip)] // We want the assembly needles to stay in lines of four bytes each
use crate::logging::*;
use training_mod_sync::LazyLock;

// Stolen from HDR who stole it from Arcropolis
// https://github.com/HDR-Development/HewDraw-Remix/blob/dev/dynamic/src/util.rs
pub fn byte_search(needle: &[u8]) -> (Option<usize>, Option<usize>) {
    let haystack = unsafe {
        let start = skyline::hooks::getRegionAddress(skyline::hooks::Region::Text) as *const u8;
        let end = skyline::hooks::getRegionAddress(skyline::hooks::Region::Rodata) as *const u8;
        let length = end.offset_from(start) as usize;
        std::slice::from_raw_parts(start, length)
    };
    use memchr::memmem;
    let first = memmem::find(haystack, needle);
    let last = memmem::rfind(haystack, needle);
    return (first, last);
}

// Wrapper around byte_search() with some additional logging
fn find_offset(name: &str, needle: &[u8]) -> Option<usize> {
    info!("Searching for {}", name);
    let offset_opt = byte_search(needle);
    if offset_opt.0 != offset_opt.1 {
        error!("Found multiple offsets for {}. Extend the bytecode to be more specific", name);
        return None;
    }
    match offset_opt.0 {
        Some(offset) => {
            info!("Found offset for {} at {:#x}", name, offset);
            Some(offset)
        }
        None => {
            error!("Cound not find offset for {}", name);
            None
        }
    }
}

macro_rules! impl_offset {
    ($fn_name:ident) => {
        paste::paste! {
            pub static [<OFFSET_ $fn_name>]: LazyLock<usize> = LazyLock::new(|| find_offset(stringify!($fn_name), [<NEEDLE_ $fn_name>]).expect(stringify!(Failed to find offset for $fn_name)));
        }
    }
}

// To add a new offset, you need to define a NEEDLE_ static first with the
// bytecode at that offset.
//
// Example:
// OFFSET_GET_BATTLE_OBJECT_FROM_ID gets defined by the NEEDLE_GET_BATTLE_OBJECT_FROM_ID
// bytecode and the impl_offset! macro with the argument GET_BATTLE_OBJECT_FROM_ID
//
// Recommended to use the first 8 instructions (32 bytes), unless the function is shorter

// OFFSET_GET_BATTLE_OBJECT_FROM_ID = 0x3ac560
static NEEDLE_GET_BATTLE_OBJECT_FROM_ID: &[u8] = &[
    0x08, 0x7c, 0x1c, 0x53,
    0x1f, 0x11, 0x00, 0x71,
    0x68, 0x07, 0x00, 0x54,
    0x49, 0x08, 0x02, 0xf0,
    0x29, 0xd1, 0x07, 0x91,
    0x28, 0x79, 0xa8, 0xb8,
    0x08, 0x01, 0x09, 0x8b,
    0x00, 0x01, 0x1f, 0xd6,
];
impl_offset!(GET_BATTLE_OBJECT_FROM_ID);

// OFFSET_COPY_SETUP = 0xba0e80
static NEEDLE_COPY_SETUP: &[u8] = &[
    0xe8, 0x0f, 0x19, 0xfc,
    0xfc, 0x6f, 0x01, 0xa9,
    0xfa, 0x67, 0x02, 0xa9,
    0xf8, 0x5f, 0x03, 0xa9,
    0xf6, 0x57, 0x04, 0xa9,
    0xf4, 0x4f, 0x05, 0xa9,
    0xfd, 0x7b, 0x06, 0xa9,
    0xfd, 0x83, 0x01, 0x91,
    0xff, 0x43, 0x17, 0xd1,
    0x18, 0xa4, 0x40, 0xf9,
    0xfa, 0x03, 0x03, 0x2a,
    0x5f, 0x18, 0x00, 0x71,
    0xc1, 0x02, 0x00, 0x54,
];
impl_offset!(COPY_SETUP);

// OFFSET_IS_VISIBLE_BACKSHIELD = 0x1655610
static NEEDLE_IS_VISIBLE_BACKSHIELD: &[u8] = &[
    0xfd, 0x7b, 0xbf, 0xa9,
    0xfd, 0x03, 0x00, 0x91,
    0x00, 0x28, 0x40, 0xf9,
    0x08, 0x00, 0x40, 0xf9,
    0x08, 0x85, 0x40, 0xf9,
    0xa1, 0x0f, 0x80, 0x52,
    0x01, 0x00, 0xa4, 0x72,
    0x00, 0x01, 0x3f, 0xd6,
];
impl_offset!(IS_VISIBLE_BACKSHIELD);

// OFFSET_SET_CPU_CONTROLS = 0x2da180
static NEEDLE_SET_CPU_CONTROLS: &[u8] = &[
    0xff, 0x03, 0x06, 0xd1,
    0xee, 0x73, 0x00, 0xfd,
    0xed, 0x33, 0x0f, 0x6d,
    0xeb, 0x2b, 0x10, 0x6d,
    0xe9, 0x23, 0x11, 0x6d,
    0xfc, 0x6f, 0x12, 0xa9,
    0xfa, 0x67, 0x13, 0xa9,
    0xf8, 0x5f, 0x14, 0xa9,
];
impl_offset!(SET_CPU_CONTROLS);

// OFFSET_ADD_DAMAGE = 0x3ff9c0
static NEEDLE_ADD_DAMAGE: &[u8] = &[
    0x08, 0x20, 0x20, 0x1e,
    0x8d, 0x00, 0x00, 0x54,
    0x08, 0x14, 0x4e, 0x39,
    0x48, 0x00, 0x00, 0x34,
    0xc0, 0x03, 0x5f, 0xd6,
];
impl_offset!(ADD_DAMAGE);

// OFFSET_CHANGE_ACTIVE_CAMERA = 0x4ee480
static NEEDLE_CHANGE_ACTIVE_CAMERA: &[u8] = &[
    0xff, 0x03, 0x02, 0xd1,
    0xf8, 0x5f, 0x04, 0xa9,
    0xf6, 0x57, 0x05, 0xa9,
    0xf4, 0x4f, 0x06, 0xa9,
    0xfd, 0x7b, 0x07, 0xa9,
    0xfd, 0xc3, 0x01, 0x91,
    0x08, 0x04, 0x40, 0xb9,
    0x1f, 0x01, 0x01, 0x6b,
];
impl_offset!(CHANGE_ACTIVE_CAMERA);

// OFFSET_SET_TRAINING_FIXED_CAMERA_VALUES = 0x3158850
static NEEDLE_SET_TRAINING_FIXED_CAMERA_VALUES: &[u8] = &[
    0x01, 0xe4, 0x00, 0x2f,
    0x20, 0x00, 0xc0, 0x3d,
    0x22, 0x1c, 0xa1, 0x4e,
    0x02, 0x44, 0x04, 0x6e,
];
impl_offset!(SET_TRAINING_FIXED_CAMERA_VALUES);

// OFFSET_DRAW = 0x4b620
static NEEDLE_DRAW: &[u8] = &[
    0x08, 0x0c, 0x40, 0xf9,
    0xc8, 0x03, 0x00, 0xb4,
    0xff, 0x83, 0x01, 0xd1,
    0xf5, 0x1b, 0x00, 0xf9,
    0xf4, 0x4f, 0x04, 0xa9,
    0xfd, 0x7b, 0x05, 0xa9,
    0xfd, 0x43, 0x01, 0x91,
    0xf4, 0x03, 0x00, 0xaa,
];
impl_offset!(DRAW);

// OFFSET_CLOUD_ADD_LIMIT = 0x8dc160
static NEEDLE_CLOUD_ADD_LIMIT: &[u8] = &[
    0xff, 0x03, 0x03, 0xd1,
    0xe9, 0x23, 0x05, 0x6d,
    0xfc, 0x6f, 0x06, 0xa9,
    0xfa, 0x67, 0x07, 0xa9,
    0xf8, 0x5f, 0x08, 0xa9,
    0xf6, 0x57, 0x09, 0xa9,
    0xf4, 0x4f, 0x0a, 0xa9,
    0xfd, 0x7b, 0x0b, 0xa9,
    0xfd, 0xc3, 0x02, 0x91,
    0x13, 0x28, 0x40, 0xf9,
    0x68, 0x02, 0x40, 0xf9,
    0x08, 0x85, 0x40, 0xf9,
];
impl_offset!(CLOUD_ADD_LIMIT);

// IMPORTANT! Because this offset is so close to OFFSET_STALE and
// because we are modifying inline instead of hooking the whole function,
// this hook has to be initialized first! Otherwise the search will fail.
// OFFSET_STALE_MENU = 0x13e88c0
static NEEDLE_STALE_MENU: &[u8] = &[
    0xdf, 0x82, 0x2d, 0x39,
    0xab, 0x44, 0x8e, 0x94,
    0x00, 0x1d, 0xa8, 0x4e,
    0xc0, 0xa2, 0x06, 0x91,
];
impl_offset!(STALE_MENU);

// IMPORTANT! See above comment for STALE_MENU
// OFFSET_STALE = 0x13e88c4
static NEEDLE_STALE: &[u8] = &[
    0xab, 0x44, 0x8e, 0x94,
    0x00, 0x1d, 0xa8, 0x4e,
    0xc0, 0xa2, 0x06, 0x91,
    0xdf, 0x22, 0x2f, 0x39,
];
impl_offset!(STALE);

// todo!(Can we remove this and replace with SoundModule::play_se()?)
// OFFSET_PLAY_SE = 0x4cf6c0
static NEEDLE_PLAY_SE: &[u8] = &[
    0xa8, 0x00, 0x00, 0x12,
    0x9f, 0x00, 0x00, 0x72,
    0xe9, 0x03, 0x1e, 0x32,
    0x24, 0x11, 0x88, 0x1a,
    0x42, 0x00, 0x00, 0x12,
    0x63, 0x00, 0x00, 0x12,
    0xe5, 0x03, 0x06, 0x2a,
];
impl_offset!(PLAY_SE);

// OFFSET_CAN_FUTTOBI_BACK = 0x26105f0
static NEEDLE_CAN_FUTTOBI_BACK: &[u8] = &[
    0x00, 0x07, 0x00, 0xb4,
    0x09, 0x04, 0x40, 0xf9,
    0x28, 0x01, 0x40, 0x39,
    0x1f, 0x31, 0x00, 0x71,
    0x41, 0x04, 0x00, 0x54,
    0x28, 0x11, 0x40, 0xb8,
    0x0a, 0x05, 0x00, 0x71,
    0xeb, 0x03, 0x00, 0x54,
    0x0d, 0x00, 0x40, 0xf9,
    0x28, 0x51, 0x80, 0xb8,
    0x8e, 0x7b, 0x94, 0xd2,
    0x8e, 0x0d, 0xb7, 0xf2,
];
impl_offset!(CAN_FUTTOBI_BACK);

// OFFSET_REUSED_UI = 0x68cda0
static NEEDLE_REUSED_UI: &[u8] = &[
    0xff, 0x43, 0x01, 0xd1,
    0xf5, 0x13, 0x00, 0xf9,
    0xf4, 0x4f, 0x03, 0xa9,
    0xfd, 0x7b, 0x04, 0xa9,
    0xfd, 0x03, 0x01, 0x91,
    0x08, 0x00, 0x40, 0xb9,
    0x1f, 0x21, 0x00, 0x71,
    0x62, 0x06, 0x00, 0x54,
];
impl_offset!(REUSED_UI);


// OFFSET_OPCF = 0x6b7ffc
static NEEDLE_OPCF: &[u8] = &[
    0x68, 0xb6, 0x40, 0xf9,
    0x09, 0x81, 0x49, 0x39,
    0x69, 0xe1, 0xff, 0x35,
    0x08, 0x55, 0x41, 0x39,
    0x28, 0xe1, 0x1f, 0x37,
    0xe0, 0x03, 0x13, 0xaa,
    0x5b, 0x88, 0xf0, 0x97,
    0xe9, 0x23, 0x43, 0x6d,
];
impl_offset!(OPCF);

// OFFSET_FIM = 0x1750f70
static NEEDLE_FIM: &[u8] = &[
    0xff, 0x03, 0x02, 0xd1,
    0xf7, 0x23, 0x00, 0xf9,
    0xf6, 0x57, 0x05, 0xa9,
    0xf4, 0x4f, 0x06, 0xa9,
    0xfd, 0x7b, 0x07, 0xa9,
    0xfd, 0xc3, 0x01, 0x91,
    0x3f, 0x04, 0x00, 0x31,
    0xe0, 0x77, 0x00, 0x54,
];
impl_offset!(FIM);

// OFFSET_SSS_TRAINING = 0x184dcc8
static NEEDLE_SSS_TRAINING: &[u8] = &[
    0x9f, 0xe3, 0x0b, 0x39,
    0x88, 0xbf, 0x0b, 0x39,
    0x56, 0x02, 0x00, 0x14,
    0x00, 0x01, 0x00, 0xf9,
    0xe8, 0x03, 0x00, 0x32,

];
impl_offset!(SSS_TRAINING);

// OFFSET_GENERATE_ARTICLE_FOR_TARGET = 0x3d40c0
static NEEDLE_GENERATE_ARTICLE_FOR_TARGET: &[u8] = &[
    0xf4, 0x4f, 0xbe, 0xa9,
    0xfd, 0x7b, 0x01, 0xa9,
    0xfd, 0x43, 0x00, 0x91,
    0xf3, 0x03, 0x03, 0x2a,
    0x42, 0x00, 0x00, 0xb5,
    0x02, 0x04, 0x40, 0xf9,
];
impl_offset!(GENERATE_ARTICLE_FOR_TARGET);

// OFFSET_KIRBY_OPFF = 0xb971d0
static NEEDLE_KIRBY_OPFF: &[u8] = &[
    0xff, 0x43, 0x02, 0xd1,
    0xfc, 0x6f, 0x03, 0xa9,
    0xfa, 0x67, 0x04, 0xa9,
    0xf8, 0x5f, 0x05, 0xa9,
    0xf6, 0x57, 0x06, 0xa9,
    0xf4, 0x4f, 0x07, 0xa9,
    0xfd, 0x7b, 0x08, 0xa9,
    0xfd, 0x03, 0x02, 0x91,
    0x3a, 0x10, 0x40, 0xf9,
    0x54, 0x2b, 0x40, 0xf9,
    0x88, 0x02, 0x40, 0xf9,
    0x08, 0x59, 0x40, 0xf9,
];
impl_offset!(KIRBY_OPFF);

// OFFSET_ACTIVATE_AUTONOMY = 0x34B6720
static NEEDLE_ACTIVATE_AUTONOMY: &[u8] = &[
    0xf6, 0x57, 0xbd, 0xa9,
    0xf4, 0x4f, 0x01, 0xa9,
    0xfd, 0x7b, 0x02, 0xa9,
    0xfd, 0x83, 0x00, 0x91,
    0x28, 0x00, 0x40, 0xf9,
    0x08, 0x89, 0x40, 0xf9,
    0xd5, 0x00, 0x80, 0x52,
    0x15, 0x00, 0xa4, 0x72,
];
impl_offset!(ACTIVATE_AUTONOMY);

// OFFSET_POKEMON_DECIDE = 0x34CE694
static NEEDLE_POKEMON_DECIDE: &[u8] = &[
    0x28, 0x69, 0x2b, 0x38,
    0x48, 0x26, 0x8b, 0x52,
    0x2a, 0x69, 0x28, 0x38,
    0x88, 0x12, 0x40, 0xf9,
];
impl_offset!(POKEMON_DECIDE);

// OFFSET_LAYOUT_ARC_MALLOC = 0x3774154
static NEEDLE_LAYOUT_ARC_MALLOC: &[u8] = &[
    0xe3, 0xe6, 0x06, 0x94,
    0xa0, 0x05, 0x00, 0xb4,
    0xe1, 0x03, 0x15, 0xaa,
    0xe2, 0x03, 0x17, 0xaa,
];
impl_offset!(LAYOUT_ARC_MALLOC);

// OFFSET_TRAINING_RESET_CHECK = 0x1378e50
static NEEDLE_TRAINING_RESET_CHECK: &[u8] = &[
    0x1f, 0x09, 0x00, 0x71,
    0x41, 0x1c, 0x00, 0x54,
    0x08, 0xfa, 0x01, 0x90,
    0x08, 0x7d, 0x42, 0xf9,
    0x08, 0x01, 0x40, 0xf9,
    0x09, 0xa1, 0x40, 0xb9,
    0x3f, 0x05, 0x00, 0x71,
    0x2b, 0x0a, 0x00, 0x54,
];
impl_offset!(TRAINING_RESET_CHECK);
